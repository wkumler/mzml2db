% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mzml2db_functions.R
\name{mzml2db}
\alias{mzml2db}
\title{Convert mzML files to database}
\usage{
mzml2db(
  ms_files,
  db_engine = duckdb::duckdb(),
  db_name,
  verbosity = NULL,
  scan_batch_size = 10000,
  sort_by = NULL,
  ...
)
}
\arguments{
\item{ms_files}{A list of the files to write into the database, including
their paths (although only the basename will be written into the filename
column)}

\item{db_engine}{The database connector to use, e.g. RSQLite::SQLite(),
duckdb::duckdb(), or RPostgreSQL::PostgreSQL()}

\item{db_name}{The name of the database you'd like to write out to}

\item{verbosity}{Three levels of processing output to the R console are
available, with increasing verbosity corresponding to higher integers. A
verbosity of zero means that no output will be produced, useful when
wrapping within larger functions. A verbosity of 1 will produce a progress
bar using base R's txtProgressBar function. A verbosity of 2 or higher will
produce timing output for each individual file read in. The default, NULL,
will select between 1 and 2 depending on the number of files being read: if
a single file, verbosity is set to 2; if multiple files, verbosity is set
to 1.}

\item{scan_batch_size}{Some files are too large to read into memory all at
once (looking at you, Thermo Astral data). This argument controls the number
of scans that should be read into memory before writing them into the
database. If the function begins to hang or consume too much memory, reduce
this value.}

\item{sort_by}{Column name for sorting batches by when written to database.
Can speed up retrieval by a single column (e.g. mz) but will create a penalty
for the others as they then become essentially randomized. Only really
relevant for DBs with range indexes (e.g. DuckDB). The default, NULL, does
not perform sorting (and thereby basically indexes by filename and scan_idx).}
}
\value{
db_name, if successful
}
\description{
This function is the core of the mzml2db package, converting mzML files into
a relational database specified by `db_engine`. It parses the mzML files one
at a time using R's XML library and writes the MS1 and MS2 data out to the
database specified in `db_name`. This allows for rapid SQL-based queries of
the associated data using R-native syntax and minimal memory.
}
\details{
The database constructed consists (currently) of two tables, one named MS1
and the other named MS2. The MS1 table has columns for filename, retention
time (rt), m/z ratio (mz), and intensity (int). The MS2 table has columns
for filename, retention time, precursor m/z (premz), fragment m/z (fragmz),
and intensity (if the files have MS2 information in them). I'm planning to
add additional tables with file and scan data but haven't gotten to that yet.
}
\examples{
# Use demo files available in the RaMS package
library(RaMS)
ms_files <- list.files(system.file("extdata", package="RaMS"),
                       pattern = "mzML", full.names = TRUE)[2:4]
# DuckDB are nice and small, pretty speedy
mzml2db(ms_files, db_engine = duckdb::duckdb(), db_name = "minidata.duckdb")
# SQLite is well supported but can get to be large (~3x mzML size)
mzml2db(ms_files, db_engine = RSQLite::SQLite, db_name = "minidata.sqlite")

conn <- dbConnect(duckdb::duckdb(), "minidata.duckdb")

# Write raw SQL to extract a chromatogram
bet_chrom <- dbGetQuery(conn, "SELECT * FROM MS1 WHERE mz BETWEEN 118.0 AND 118.1")
plot(bet_chrom$rt, bet_chrom$int, type="l")

# Or calculate a BPC/TIC and use ggplot2 to graph it
library(ggplot2)
bpc_query <- "SELECT filename, rt, MAX(int) AS int FROM MS1 GROUP BY rt, filename"
manual_bpc <- dbGetQuery(conn, bpc_query)
ggplot(manual_bpc) + geom_line(aes(x=rt, y=int, group=filename))

# Alternatively, use the dbplyr interface and treat it like a tibble
library(dplyr)
library(dbplyr)
conn \%>\%
  tbl("MS1") \%>\%
  filter(between(mz, 118.0, 118.1)) \%>\%
  ggplot() +
  geom_line(aes(x=rt, y=int, group=filename))

# Remember to clean up afterward!
dbDisconnect(conn)
unlink("minidata.duckdb")
unlink("minidata.sqlite")
}
